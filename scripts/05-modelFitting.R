# model fitting script ----------------------------------------------------

## a script `sourced` by the .Rmd to fit the statistical models.


# info --------------------------------------------------------------------

## use changelog
# snippet changelog

## use snippets for todos
# snippet todo-bug
# snippet todo-check-me
# snippet todo-document-me
# snippet todo-fix-me
# snippet todo-optimise-me
# snippet todo-test-me

# use snippets for code chunks
# snippet saveplot
# snippet loadlatestdata


# change log --------------------------------------------------------------

## changelog
##! CHANGE LOG: (20221221 07:49:16) Modified the model comparison table


# additional libraries ----------------------------------------------------


# additional setup --------------------------------------------------------


# data --------------------------------------------------------------------

## read data
load(here(data_dir, "all-vars-for-analysis.RData"))

## add indicator for RSE river
dat_sub$isRSE <- ifelse(dat_sub$RiverName %in% rse_rivers, 
                        TRUE,
                        FALSE)


# separate data -----------------------------------------------------------

## split data into those with RSE and those without
dat_sub_rse <- subset(dat_sub, !is.na(RSE))
dat_sub_nonrse <- subset(dat_sub, is.na(RSE))


# data standardisation ----------------------------------------------------

## standardised data names
std_vars <- paste0(cont_vars, "_std")

## do standardisation
dat_sub_rse[, (std_vars) := lapply(.SD, function(x) scale(x)), 
            .SDcols = cont_vars]

## check
if (do_chks) {
  print(apply(dat_sub[, ..std_vars], 2, mean)) # ~ 0
  print(apply(dat_sub[, ..std_vars], 2, sd)) # = 1
}

## do standardisation
dat_sub_nonrse[, (std_vars) := lapply(.SD, function(x) scale(x)), 
               .SDcols = cont_vars]


# collinearity checks -----------------------------------------------------

## check for high collinearity (|r| > 0.6)
cor_mat <- data.table(cor(dat_sub_rse[, ..std_vars]), keep.rownames = "Variable 1")

## stack them
cor_dt <- melt(cor_mat, id.vars = "Variable 1", variable.name = "Variable 2")

## ensure variable orders
cor_dt$`Variable 1` <- factor(cor_dt$`Variable 1`, levels = std_vars)
cor_dt$`Variable 2` <- factor(cor_dt$`Variable 2`, levels = std_vars)

## plot it
cor_mat_p <- ggplot(cor_dt, aes(x = `Variable 1`, y = `Variable 2`)) + 
  geom_tile(color = "white", aes(fill = value)) +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), space = "Lab", 
                       name = "Pearson\nCorrelation") +
  geom_text(aes(label = round(value, 1))) +
  sgg(tfs = 16, lfs = 16) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0),
        axis.text = element_text(size = 14))


# model preparation -------------------------------------------------------

## create ur between (0, 1)
dat_sub_rse$ur <- dat_sub_rse$ur_rse / 100

## ensure factors
dat_sub_rse$RiverName <- factor(dat_sub_rse$RiverName)
dat_sub_rse$Year <- factor(dat_sub_rse$Year)

## ensure SalCatch and RSE are integers
dat_sub_rse$SalCatch <- as.integer(floor(dat_sub_rse$SalCatch))
dat_sub_rse$RSE <- as.integer(floor(dat_sub_rse$RSE))


# models ------------------------------------------------------------------

## model specifications
saturated <- bf(SalCatch | trials(RSE) ~ 1 + 
                  poly(DeclSalEffHa_std, 2, raw = TRUE) +
                  SuccessEff_std + 
                  mnflow_std + 
                  BaseFlowIdx_std +
                  pRelease_std + 
                  (1|RiverName) + (1|Year),
                phi ~ 1 + 
                  AreaHA_std)
noBaseFlowIdx <- bf(SalCatch | trials(RSE) ~ 1 + 
                      poly(DeclSalEffHa_std, 2, raw = TRUE) +
                      SuccessEff_std + 
                      mnflow_std + 
                      pRelease_std + 
                      (1|RiverName) + (1|Year),
                    phi ~ 1 + 
                      AreaHA_std)
noAreaHA <- bf(SalCatch | trials(RSE) ~ 1 + 
                 poly(DeclSalEffHa_std, 2, raw = TRUE) +
                 SuccessEff_std + 
                 mnflow_std + 
                 BaseFlowIdx_std +
                 pRelease_std + 
                 (1|RiverName) + (1|Year),
               phi ~ 1)
noBaseFlowIdxAreaHA <- bf(SalCatch | trials(RSE) ~ 1 + 
                            poly(DeclSalEffHa_std, 2, raw = TRUE) +
                            SuccessEff_std + 
                            mnflow_std + 
                            pRelease_std + 
                            (1|RiverName) + (1|Year),
                          phi ~ 1)
noBaseFlowIdxAreaHAmnflow <- bf(SalCatch | trials(RSE) ~ 1 + 
                                  poly(DeclSalEffHa_std, 2, raw = TRUE) +
                                  SuccessEff_std + 
                                  pRelease_std + 
                                  (1|RiverName) + (1|Year),
                                phi ~ 1)

## model list
mdl_lst <- list("saturated" = saturated, 
                "no BaseFlowIdx" = noBaseFlowIdx,
                "no AreaHA" = noAreaHA, 
                "no BaseFlowIdx or AreaHA" = noBaseFlowIdxAreaHA,
                "no BaseFlowIdx or AreaHA or mnflow" = noBaseFlowIdxAreaHAmnflow)


# custom family function --------------------------------------------------

## if using cauchit, redefine mdl_lst and define beta_binomial2
if (use_cauchit) {
  
  ### trials -> vint in mdl_lst 
  for (i in 1:length(mdl_lst)) {
    mdl_lst[[i]]$formula <- update.formula(mdl_lst[[i]]$formula,
                                           SalCatch | vint(RSE) ~ .)
  }
  
  ### redefine beta_binomial
  beta_binomial2 <- custom_family("beta_binomial2", 
                                  dpars = c("mu", "phi"),
                                  links = c("cauchit", "identity"), 
                                  lb = c(NA, NA),
                                  type = "int", 
                                  vars = "vint1[n]")
} else {
  
  ### if logit, define beta_binomial2 as brms::beta_binomial
  beta_binomial2 <- beta_binomial(link = "logit", link_phi = "log")

}


# fit model ---------------------------------------------------------------

## holding objects
prs_lst <- res_lst <- vector("list", length(mdl_lst))
names(prs_lst) <- names(res_lst) <- names(mdl_lst)

## in a loop
for (m in 1:length(mdl_lst)) {
  
  ### get priors
  prs <- get_prior(mdl_lst[[m]], 
                   data = dat_sub_rse, family = beta_binomial2)
  
  ### modify priors - change intercepts and betas from flat to norm
  ### see https://betanalpha.github.io/assets/case_studies/weakly_informative_shapes.html
  prs$prior[which(prs$class %in% c("b", "Intercept"))] <- "normal(0, 1)"

  ### estimate parameters
  fit <- brm(mdl_lst[[m]],
             data = dat_sub_rse,
             family = beta_binomial2, # (link = "logit", link_phi = "log"),
             prior = prs,
             warmup = setts$nb,
             iter = Reduce("+", setts[c("nb", "ni")]),
             chains = setts$nc, 
             cores = setts$nc,
             save_pars = save_pars(all = TRUE),
             control = list(adapt_delta = 0.99),
             stanvars = stanvars)
  
  ### expose functions
  if (m == 1) {
    expose_functions(fit, vectorize = TRUE)
  }
  
  ### add model comparison criteria
  fit <- add_criterion(fit, criterion = "waic")
  fit <- add_criterion(fit, criterion = "loo")
  fit <- add_criterion(fit, criterion = "bayes_R2")
    
  ### add to holding objects
  prs_lst[[m]] <- prs
  res_lst[[m]] <- fit
 
}


# model comparisons -------------------------------------------------------

## compare using elpd_loo
loo_obj <- lapply(res_lst, loo)
loo_tab <- loo_compare(loo_obj)

## make table
res_tab <- data.table(loo_tab, keep.rownames = "name")

## formula column
frm_col_mu <- unlist(lapply(lapply(mdl_lst, as.character), "[[", 1))
frm_col_mu <- gsub("1 \\+ poly\\(|, 2, raw = TRUE\\)|_std)", "", frm_col_mu)
frm_col_mu <- gsub("SalCatch \\| vint\\(RSE\\)", "Catch | RSE, mu", frm_col_mu)
frm_col_phi <- unlist(lapply(lapply(mdl_lst, as.character), "[[", 2))
frm_col_phi <- gsub("list\\(phi = |\\)$", "", frm_col_phi)

## delta_looic column
dlooic_col <- res_tab$looic - res_tab$looic[1]

## R2 column
r2_obj <- lapply(res_lst, bayes_R2)
r2_col <- unlist(lapply(r2_obj, "[[", 1))

## add additional columns
res_tab$`mu formula` <- frm_col_mu[res_tab$name]
res_tab$`phi formula` <- frm_col_phi[res_tab$name]
res_tab$delta_looic <- dlooic_col
res_tab$R2 <- r2_col[res_tab$name]

## count number of fixed coefs
res_ncoefs <- lapply(res_lst, function(v) nrow(fixef(v)))

## best model (dlooic < 2 & min ncoefs)
res_tab_o <- res_tab[match(names(res_lst), res_tab$name), ]
res_delta_lt2 <- unlist(which(res_tab_o$delta_looic < 2))
best_model <- which.min(unlist(res_ncoefs[res_delta_lt2]))

## add most parsimonious (best) model
res_tab[, "best" := ifelse(name == names(best_model), 1, 0)]

## order columns
setcolorder(res_tab, c("name", 
                       "mu formula", "phi formula", 
                       "looic", "delta_looic", "R2", "best"))

## write out the table
if (save_it) {
  f_nm <- paste0("model-comparison-table.csv")
  write.csv(res_tab, here("results", f_nm), row.names = FALSE)
}  

## save the fit
best_fit <- res_lst[[names(best_model)]]


# save plots --------------------------------------------------------------

## get plot objects
p_objs <- c("cor_mat_p")

## make plots in a loop
if (make_plots) {
  for (p in p_objs) {
    
    ### file name
    f_nm <- paste0("dat-", gsub("_", "-", p), "lot")
    
    ### pdf
    cairo_pdf(here("plots", paste0(f_nm, ".pdf")),
              width = 10, height = 7)
    print(eval(as.name(p)))
    dev.off()
    
    ### jpg
    jpeg(here("plots", paste0(f_nm, ".jpg")),
         res = 600, width = (480 * 10), height = (480 * 7))
    print(eval(as.name(p)))
    dev.off()
    
  }
}


# save --------------------------------------------------------------------

## save list
save_lst <- c(
  
  ### model data & plot
  "dat_sub_rse", # model data
  "dat_sub_nonrse", # data for extrapolation later
  "cor_dt", # corr data
  "cor_mat_p", # corr plot
  
  ### model priors and fits
  "mdl_lst", # list of model formulas
  "prs_lst", # list of model priors
  "res_lst", # list of model fits
  "best_model", # best model in res_lst
  "best_fit" # best fit
  
)

## save image
if (save_it) {
  fle_nm <- paste0("rod-exploitation-fitting-results.RData")
  save(list = save_lst, file = here("results", fle_nm))
}
